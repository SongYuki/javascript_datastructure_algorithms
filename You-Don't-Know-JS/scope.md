**分词tokenizing和词法分析lexing**之间的区别是非常微妙晦涩的，主要差异在于词法单元的识别是通过**有状态**还是**无状态**的方式进行的。

**解析/语法分析Parsing**将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树**Abstract Syntax Tree**


**代码生成**：将AST转换为可执行代码的过程，这个过程与语言，目标平台等息息相关。


在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化。


对JS来说，大部分情况下编译发生在代码执行前的几微妙时间内。在**作用域**背后，JS引擎用尽了各种办法（JIT可以延迟编译甚至实施重编译）来保证性能最佳


为了能**完全理解**JS的工作原理，你需要像引擎一样**思考**从它的角度提出并回答这些问题


**引擎**从头到尾负责整个JS程序的编译及执行过程

**编译器**引擎的好朋友之一，负责语法分析及代码生成等脏活累活

**作用域**引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限


var a = 2;
引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一个则由引擎在运行时处理


var a = 2;的分解
编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。

**但是当编译器开始进行代码生成时，它对这段程序的处理方式和预期有所不同**

 1. 遇到var a编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a
 2. 接下来编译器为引擎生成运行时所需的代码，这些代码被用来处理a=2这个赋值操作。**引擎运行时首先询问作用域，在当前的作用域集合中是否存在一个叫做a的变量。如果是，引擎就会使用这个变量，如果否，引擎会继续查找该变量**
 

引擎为变量a进行LHS查询，另外一个查找的类型叫做RHS

**当变量出现在赋值操作的左侧时进行LHS查询出现在右侧时进行RHS查询**


```console.log(a);```
对a的引用是一个RHS引用，因为这里a并没有赋予任何值。需要查找并取得a的值才能将值传递给console.log()

```a=2;```
对a的引用是LHS引用，实际上当前的值我们并不关心，只想为=2这个赋值操作找到一个目标

**赋值操作的目标是谁LHS/谁是赋值操作的源头RHS**


